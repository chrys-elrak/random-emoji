const textareas = document.querySelectorAll('textarea');
const OFFSETS = 10;
if (textareas.length) {
    const textarea = textareas[0];
    textarea.addEventListener('focus', () => {
        main(textarea);
    });

    // textarea.addEventListener('blur', () => {
    //     const container = document.querySelector('.container');
    //     if (container) {
    //         container.remove();
    //     }
    // });
}

function main(textarea) {
    const pos = getOffset(textarea)
    const div = document.createElement('div');
    // update position
    div.style.top = pos.top + pos.height + OFFSETS + 'px';
    div.style.left = pos.left + pos.width + OFFSETS + 'px';
    div.style.position = 'absolute';
    div.setAttribute('tabindex', '0');
    // create loader
    const loader = document.createElement('div');
    loader.innerHTML = `
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="margin: auto; background: rgb(255, 255, 255); display: block; shape-rendering: auto;"
    width="140px" height="150px" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid">
    <circle cx="50" cy="50" r="0" fill="none" stroke="#e90c59" stroke-width="2">
        <animate attributeName="r" repeatCount="indefinite" dur="0.8695652173913042s" values="0;40"
            keyTimes="0;1" keySplines="0 0.2 0.8 1" calcMode="spline" begin="0s"></animate>
        <animate attributeName="opacity" repeatCount="indefinite" dur="0.8695652173913042s" values="1;0"
            keyTimes="0;1" keySplines="0.2 0 0.8 1" calcMode="spline" begin="0s"></animate>
    </circle>
    <circle cx="50" cy="50" r="0" fill="none" stroke="#46dff0" stroke-width="2">
        <animate attributeName="r" repeatCount="indefinite" dur="0.8695652173913042s" values="0;40"
            keyTimes="0;1" keySplines="0 0.2 0.8 1" calcMode="spline" begin="-0.4347826086956521s">
        </animate>
        <animate attributeName="opacity" repeatCount="indefinite" dur="0.8695652173913042s" values="1;0"
            keyTimes="0;1" keySplines="0.2 0 0.8 1" calcMode="spline" begin="-0.4347826086956521s">
        </animate>
    </circle>
    <!-- [ldio] generated by https://loading.io/ -->
</svg>
    `;
    // add the class
    div.classList.add('container');
    // create emoji for the div
    const emojiField = document.createElement('h1');
    emojiField.classList.add('emoji-field', 'unselectable', 'hidden');
    emojiField.addEventListener('click', () => {
        textarea.value += emojiField.innerText;
    });
    // add emoji to the div
    getEmoji()
        .then(emoji => {
            emojiField.innerHTML = emoji;
            loader.classList.add('hidden');
            emojiField.classList.remove('hidden');
        });
    // add the content to the div
    div.appendChild(emojiField);
    // create the close button
    const close = document.createElement('button');
    close.classList.add('button', 'close');
    close.innerHTML = '&times;';
    close.addEventListener('click', () => {
        div.remove();
    });
    // create random emoji
    const random = document.createElement('button');
    random.classList.add('button', 'random');
    random.innerHTML = '&#8634;';
    random.addEventListener('click', async () => {
        loader.classList.remove('hidden');
        emojiField.classList.add('hidden');
        emojiField.innerHTML = await getEmoji();
        loader.classList.add('hidden');
        emojiField.classList.remove('hidden');
    });
    // button container
    const buttonContainer = document.createElement('div');
    buttonContainer.classList.add('button-container');
    // add the content to the div
    buttonContainer.appendChild(random);
    buttonContainer.appendChild(close);
    // Add loader
    div.appendChild(loader);
    // Add buttons to the button container
    div.appendChild(buttonContainer);
    // Main container
    document.body.appendChild(div);
}


function getOffset(el) {
    const rect = el.getBoundingClientRect();
    return {
        left: rect.left + window.scrollX,
        top: rect.top + window.scrollY,
        width: rect.width,
        height: rect.height
    };
}

function getEmoji() {
    return fetch('https://ranmoji.herokuapp.com/emojis/api/v.1.0/').then(res => res.json()).then(data => data.emoji);
}